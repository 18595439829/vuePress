{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[23],{377:function(n,e,t){\"use strict\";t.r(e);var r=t(44),a=Object(r.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"js将数组对象转化为树形结构\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#js将数组对象转化为树形结构\"}},[n._v(\"#\")]),n._v(\" js将数组对象转化为树形结构\")]),n._v(\" \"),t(\"h2\",{attrs:{id:\"第一种方法-使用for循环-性能比递归好很多-推荐使用\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#第一种方法-使用for循环-性能比递归好很多-推荐使用\"}},[n._v(\"#\")]),n._v(\" 第一种方法: 使用for循环(性能比递归好很多,推荐使用)\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"    // jsonData: 数组对象\\n    // id: 每条数据的id\\n    // pid: 每条数据的父节点对应字段\\n    /*\\n      [\\n        {\\n          name: '测试',\\n          id: '1001',\\n          pid: '-1',\\n        }\\n      ] \\n    */\\n    jsonToTree(jsonData, id, pid) {\\n      let result = [],\\n        temp = {};\\n      for (let i = 0; i < jsonData.length; i++) {\\n        temp[jsonData[i][id]] = jsonData[i]; // 以id作为索引存储元素，可以无需遍历直接定位元素\\n      }\\n      for (let j = 0; j < jsonData.length; j++) {\\n        let currentElement = jsonData[j];\\n        let tempCurrentElementParent = temp[currentElement[pid]]; // 临时变量里面的当前元素的父元素\\n        if (tempCurrentElementParent) {\\n          // 如果存在父元素\\n          if (!tempCurrentElementParent[\\\"children\\\"]) {\\n            // 如果父元素没有chindren键\\n            tempCurrentElementParent[\\\"children\\\"] = []; // 设上父元素的children键\\n          }\\n          tempCurrentElementParent[\\\"children\\\"].push(currentElement); // 给父元素加上当前元素作为子元素\\n        } else {\\n          // 不存在父元素，意味着当前元素是一级元素\\n          result.push(currentElement);\\n        }\\n      }\\n      return result;\\n    }\\n\")])])]),t(\"h2\",{attrs:{id:\"第二种方法-使用递归的方式\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#第二种方法-使用递归的方式\"}},[n._v(\"#\")]),n._v(\" 第二种方法: 使用递归的方式:\")]),n._v(\" \"),t(\"div\",{staticClass:\"language- extra-class\"},[t(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[t(\"code\",[n._v(\"translateDataToTree(data) {\\n    // 没有父节点的数据\\n    const parent = data.filter(value => value.pid.trim() === '-1'\\n    || value.pid.trim() === null\\n    || value.pid.trim() === '');\\n\\n    // 有父节点的数据\\n    const child = data.filter(value => value.pid.trim() !== '-1'\\n    && value.pid.trim() !== null\\n    && value.pid.trim() !== '');\\n\\n\\n    // 定义转换方法的具体实现\\n    const translator = (parents, children) => {\\n      // 遍历父节点数据\\n      parents.forEach((item) => {\\n        // 遍历子节点数据\\n        children.forEach((current, index) => {\\n          // 此时找到父节点对应的一个子节点\\n          // if (current.pid === parent.id) {\\n          if (current.pid === item.id) {\\n            // 对子节点数据进行深复制，这里只支持部分类型的数据深复制，\\n            const temp = JSON.parse(JSON.stringify(children));\\n            // 让当前子节点从temp中移除，temp作为新的子节点数据，这里是为了让递归时，子节点的遍历次数更少，如果父子关系的层级越多，越有利\\n            temp.splice(index, 1);\\n            // 让当前子节点作为唯一的父节点，去递归查找其对应的子节点\\n            translator([current], temp);\\n            // 把找到子节点放入父节点的children属性中\\n            if (typeof item.children !== 'undefined') {\\n              item.children.push(current);\\n            } else {\\n              // eslint-disable-next-line no-param-reassign\\n              item.children = [current];\\n            }\\n          }\\n        });\\n      });\\n    };\\n\\n    // 调用转换方法\\n    translator(parent, child);\\n    // 返回最终的结果\\n    return parent;\\n  },\\n\")])])])])}),[],!1,null,null,null);e.default=a.exports}}]);","extractedComments":[]}